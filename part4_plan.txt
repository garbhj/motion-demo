Step A — Backend Inventory

server/game/state.go
```
type State struct {
	Tick    int
	Players map[string]*Player
}

type Player struct {
	ID           string
	X, Y, VX, VY float64
}
```

server/game/input.go
```
type Input struct {
	Ax, Ay float64
	Boost  bool
}
```

server/game/step.go
```
func Step(s *State, inputs map[string]Input) {
	s.Tick++
	// For each player:
	// - if input magnitude > Deadzone: accel along input (Boost multiplies)
	// - damping v /= DampingDiv
	// - clamp speed to MaxSpeed
	// - integrate pos
}
```
Currently only player movement is updated.

server/protocol/server.go
```
type State struct {
	Tick    int              `json:"tick"`
	Players []PlayerSnapshot `json:"players"`
}

type PlayerSnapshot struct {
	ID string  `json:"id"`
	X  float64 `json:"x"`
	Y  float64 `json:"y"`
	A  float64 `json:"a,omitempty"`
}
```
No flails/rope/score/radius/vx/vy in protocol state.

server/protocol/protocol.go
```
type Envelope struct {
	T string          `json:"t"`
	P json.RawMessage `json:"p"`
}
```
Message types: hello/input/welcome/state.

server/protocol/codec.go
- Encode(t,p) wraps {t,p} and JSON marshals.
- DecodeEnvelope(b) JSON unmarshals into Envelope.
- DecodePayload[T](env) JSON unmarshals env.P.

server/room/room.go
Snapshot build:
```
func (r *Room) buildSnapshot() protocol.State {
	snapshot := protocol.State{ Tick: r.state.Tick, Players: ... }
	for id, p := range r.state.Players {
		snapshot.Players = append(snapshot.Players, protocol.PlayerSnapshot{
			ID: id, X: p.X, Y: p.Y,
		})
	}
	return snapshot
}
```
Spawn position:
```
spawn := float64(100 * idNum)
r.state.Players[playerID] = &game.Player{ID: playerID, X: spawn, Y: spawn}
```
No TODOs about flail/rope present.

server/network/network.go
- hello → join room → welcome with PlayerID string (p1, p2, ...)
- input → protocol.Input converted to game.Input (float64)
- IDs are string everywhere in server.

Step B — Frontend Expectations

Renderer uses:
Players fields: id, x, y, name (optional), score (optional)
Flails fields: x, y, ownerId, isDetached
Chain: line from owner.x/y to flail.x/y when not detached.
No rope nodes used yet.

Step C — Gaps + Minimal Part 4 Plan

Flail entity in server state: not present.
Simplest: add State.Flails map[string]*Flail (separate from Player).

Minimum protocol change:
Add Flails to protocol.State:
```
Flails []FlailSnapshot `json:"flails"`
```
with:
```
type FlailSnapshot struct {
	ID       string  `json:"id"`
	OwnerID  string  `json:"ownerId"`
	X        float64 `json:"x"`
	Y        float64 `json:"y"`
	Detached bool    `json:"isDetached"`
	A        float64 `json:"a,omitempty"`
}
```

Room snapshot conversion: include flails from game.State.Flails.

Step update order (per MATH_GUIDE):
1) Player movement
2) Flail tick (angle + damping + integrate)
3) Rope endpoints: player pos ↔ flail pos
4) Rope impulses: extension-only, k=0.1, rest=80 (affects flail, not player)
5) Integrate rope internal nodes only (3 segments)

Quirks to keep:
- Player NOT rope-affected
- Rope spring extension-only

Step D — Implementation Checklist

1) Add new structs
- server/game/flail.go:
  type Flail struct { ID, OwnerID string; X,Y,VX,VY,A,AV float64; Detached bool }
- server/game/rope.go (optional minimal rope struct)
- Vec2 helper if needed

2) Update game.State
- Add Flails map[string]*Flail

3) Update protocol.State
- Add Flails []FlailSnapshot
- Define FlailSnapshot

4) Update room snapshot
- buildSnapshot() appends flails

5) Update room join
- Create flail for each player on join

6) Update game.Step()
- Keep player movement
- Add flail tick
- Add rope constraints
