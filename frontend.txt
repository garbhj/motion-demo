Frontend gist (client/):

- Tooling: Vite app with root at `src/client`, dev server on port 3000, build output to `dist` (see `client/vite.config.js`).
- Entry: `client/src/client/index.html` is a full-screen canvas game with a menu overlay, in-game UI, and PiP camera/debug view.
- Main loop: `client/src/client/main.js` wires UI, starts/stops camera, runs three loops:
  - camera frame loop for MediaPipe hand tracking and debug overlay
  - fixed 20 FPS network loop for input and mock world state
  - render loop for drawing the game
- Hand tracking: `HandTracker.js` uses MediaPipe Tasks Vision (HandLandmarker) via CDN and draws landmarks for debug.
- Gesture logic: `HandHeuristics.js` converts landmarks to a mirrored hand position plus a gesture enum (OPEN/CLOSED/POINT/PINCH) via heuristics.
- Networking: `NetworkManager.js` is a mock client/server. It fakes a player, opponents, obstacles, flail physics, and returns a simulated world state.
- Rendering: `Renderer.js` draws map bounds/grid, obstacles, players, flails (with color by ID), and a joystick HUD for input/center.
- UI/Styling: `style.css` defines overlays, buttons, and PiP camera/debug panel.
- Dependencies: MediaPipe tasks-vision/drawing_utils, socket.io/client, express, vite (see `client/package.json`).

Overall: a Vite-based browser game prototype that uses hand-tracking as a joystick, with mock multiplayer state and a canvas renderer.

---
Planned client â†” server interface (current placeholders + intended wire types):

- Client currently does NOT connect to server; `NetworkManager.js` is a mock. It will eventually send/receive JSON envelopes matching the Go `protocol` types.
- Intended outbound from client (to server):
  - Message type: `"hello"` with payload shaped like `protocol.Hello` (Go) / `Hello` (client): `{ v: number, name?: string }`.
  - Message type: `"input"` with payload shaped like `protocol.Input` (Go) / input vector (client): `{ ax: number, ay: number, boost?: boolean }`.
- Intended inbound to client (from server):
  - Message type: `"welcome"` with payload shaped like `protocol.Welcome`: `{ playerId: string, tickHz: number }`.
  - Message type: `"state"` with payload shaped like `protocol.State`: `{ tick: number, players: PlayerSnapshot[] }` where `PlayerSnapshot = { id: string, x: number, y: number, a?: number }`.
- Envelope used for all messages (Go `protocol.Envelope`, file: `server/protocol/protocol.go`): `{ t: string, p: json }`.
- Client-side files to wire:
  - `client/src/client/NetworkManager.js`: replace mock `getLatestWorldState()` with WebSocket send/recv using the envelope above.
  - `client/src/client/main.js`: currently calls `network.joinGame()` and `network.sendPlayerInput()`; these become the actual network calls.
